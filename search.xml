<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入解析Servlet]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Servlet%2F</url>
    <content type="text"><![CDATA[以为servlet是很复杂的东西，事实上，servlet就是一个Java接口，interface! 打开idea，ctrl + shift + n，搜索servlet，就可以看到是一个只有5个方法的interface! 所以，提问中说的网络协议、http什么的，servlet根本不管！也管不着！ 那servlet是干嘛的？很简单，接口的作用是什么？==规范==呗！ servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法 init()和destroy()，还有一个处理请求的service()，也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题： 你初始化时要做什么 你销毁时要做什么 你接受到请求时要做什么 这是Java给的一种规范！就像阿西莫夫的机器人三大定律、行尸走肉里Rick的那三个问题一样，规范！ servlet是一个规范，那实现了servlet的类，就能处理请求了吗？ 答案是，不能。 你可以随便谷歌一个servlet的hello world教程，里面都会让你写一个servlet，相信我，你从来不会在servlet中写什么监听8080端口的代码，servlet不会直接和客户端打交道！ 那请求怎么来到servlet呢？答案是servlet容器，比如我们最常用的tomcat，同样，你可以随便谷歌一个servlet的helloworld教程，里面肯定会让你把servlet部署到一个容器中，不然你的servlet压根不会起作用。 tomcat才是与客户端直接打交道的家伙，他监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端。 作者：Javdroider Hong链接：https://www.zhihu.com/question/21416727/answer/339012081来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理]]></title>
    <url>%2F2018%2F03%2F21%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 多人协作默认clone是克隆master分支想在本地创建其他分支则用 1git checkout -b beanch-name 主机名(origin)/branch-name 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git版本回退(已commit，但未push的情况下)]]></title>
    <url>%2F2018%2F03%2F21%2FGit%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[1、查看当前分支的版本历史 1git log [--pretty=oneline] 2、回退至上一版本 1git reset --hard HEAD^ 3、回退至指定版本 1git reset --hard 版本号 4、吃后悔药，重返未来 1git reflog 查找出版本号再回退至指定版本 1234567现在小结一下：HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 5、查看工作区和版本库里面最新版本的区别 1git diff HEAD -- _config.yml 6、丢失工作区的修改(回到暂存区或本地版本库状态) 1234567git checkout -- _config.yml一种是_config.yml自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是_config.yml已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 7、撤销暂存区的修改(不会覆盖工作区的文件) 1git reset HEAD _config.yml 1234567又到了小结时间。场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git对远程仓库的管理（CRUD）]]></title>
    <url>%2F2018%2F03%2F21%2FGit%E5%AF%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、查看当前git仓库所连接的远程github仓库地址 1git remote -v 2、关联github仓库 1git remote add [short-name] git@github.com:malaxg/malaxg.github.io.git 3、重命名远程仓库 1git remote rename &lt;old-remote-name&gt; &lt;new-remote-name&gt; 4、修改远程仓库 1git remote set-url --push [remote-name] [newUrl] 5、删除远程仓库 1git remote rm [remote-name]]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习思路]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[学习新技术的四个要点 What? Features? How to use? When?]]></content>
  </entry>
</search>
